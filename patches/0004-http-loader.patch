diff --git a/components/net/http_loader.rs b/components/net/http_loader.rs
index 92d4ba738a2..e8cff098ca3 100644
--- a/components/net/http_loader.rs
+++ b/components/net/http_loader.rs
@@ -4,7 +4,7 @@
 
 use std::collections::{HashMap, HashSet};
 use std::iter::FromIterator;
-use std::sync::Arc as StdArc;
+use std::sync::{Arc as StdArc, Condvar, Mutex, RwLock};
 use std::time::{Duration, SystemTime, UNIX_EPOCH};
 
 use async_recursion::async_recursion;
@@ -59,7 +59,6 @@ use net_traits::{
     RedirectEndValue, RedirectStartValue, ReferrerPolicy, ResourceAttribute, ResourceFetchTiming,
     ResourceTimeValue,
 };
-use parking_lot::{Condvar, Mutex, RwLock};
 use profile_traits::mem::{Report, ReportKind};
 use profile_traits::path;
 use rustc_hash::FxHashMap;
@@ -109,6 +108,10 @@ pub struct HttpState {
     pub auth_cache: RwLock<AuthCache>,
     pub history_states: RwLock<FxHashMap<HistoryStateId, Vec<u8>>>,
     pub client: Client<Connector, crate::connector::BoxedBody>,
+    /// Unix domain socket client for local IPC connections
+    pub unix_client: Option<Client<hyperlocal::UnixConnector, crate::connector::BoxedBody>>,
+    /// Tor network client manager for anonymous browsing
+    pub tor_manager: Arc<crate::tor_connector::TorManager>,
     pub override_manager: CertificateErrorOverrideManager,
     pub embedder_proxy: Mutex<EmbedderProxy>,
 }
@@ -119,12 +122,12 @@ impl HttpState {
             Report {
                 path: path!["memory-cache", suffix],
                 kind: ReportKind::ExplicitJemallocHeapSize,
-                size: self.http_cache.read().size_of(ops),
+                size: self.http_cache.read().unwrap().size_of(ops),
             },
             Report {
                 path: path!["hsts-list", suffix],
                 kind: ReportKind::ExplicitJemallocHeapSize,
-                size: self.hsts_list.read().size_of(ops),
+                size: self.hsts_list.read().unwrap().size_of(ops),
             },
         ]
     }
@@ -143,7 +146,7 @@ impl HttpState {
             return None;
         }
 
-        let embedder_proxy = self.embedder_proxy.lock();
+        let embedder_proxy = self.embedder_proxy.lock().unwrap();
         let (ipc_sender, ipc_receiver) = generic_channel::channel().unwrap();
         embedder_proxy.send(EmbedderMsg::RequestAuthentication(
             webview_id,
@@ -286,8 +289,8 @@ fn is_schemelessy_same_site(site_a: &ImmutableOrigin, site_b: &ImmutableOrigin)
         let host_b_reg = reg_suffix(&host_b);
 
         // Step 2.2-2.3
-        (site_a.host() == site_b.host() && host_a_reg.is_empty()) ||
-            (host_a_reg == host_b_reg && !host_a_reg.is_empty())
+        (site_a.host() == site_b.host() && host_a_reg.is_empty())
+            || (host_a_reg == host_b_reg && !host_a_reg.is_empty())
     } else {
         // Step 3
         false
@@ -368,7 +371,7 @@ fn set_request_cookies(
     headers: &mut HeaderMap,
     cookie_jar: &RwLock<CookieStorage>,
 ) {
-    let mut cookie_jar = cookie_jar.write();
+    let mut cookie_jar = cookie_jar.write().unwrap();
     cookie_jar.remove_expired_cookies_for_url(url);
     if let Some(cookie_list) = cookie_jar.cookies_for_url(url, CookieSource::HTTP) {
         headers.insert(
@@ -379,7 +382,7 @@ fn set_request_cookies(
 }
 
 fn set_cookie_for_url(cookie_jar: &RwLock<CookieStorage>, request: &ServoUrl, cookie_val: &str) {
-    let mut cookie_jar = cookie_jar.write();
+    let mut cookie_jar = cookie_jar.write().unwrap();
     let source = CookieSource::HTTP;
 
     if let Some(cookie) = ServoCookie::from_cookie_string(cookie_val, request, source) {
@@ -509,6 +512,7 @@ pub fn send_response_values_to_devtools(
 
         let _ = devtools_chan
             .lock()
+            .unwrap()
             .send(DevtoolsControlMsg::FromChrome(msg));
     }
 }
@@ -544,7 +548,7 @@ pub fn send_early_httprequest_to_devtools(request: &Request, context: &FetchCont
             NetworkEvent::HttpRequest(devtools_request),
         );
 
-        send_request_to_devtools(msg, &devtools_chan.lock());
+        send_request_to_devtools(msg, &devtools_chan.lock().unwrap());
     }
 }
 
@@ -552,7 +556,12 @@ fn auth_from_cache(
     auth_cache: &RwLock<AuthCache>,
     origin: &ImmutableOrigin,
 ) -> Option<Authorization<Basic>> {
-    if let Some(auth_entry) = auth_cache.read().entries.get(&origin.ascii_serialization()) {
+    if let Some(auth_entry) = auth_cache
+        .read()
+        .unwrap()
+        .entries
+        .get(&origin.ascii_serialization())
+    {
         let user_name = &auth_entry.user_name;
         let password = &auth_entry.password;
         Some(Authorization::basic(user_name, password))
@@ -669,8 +678,7 @@ async fn obtain_response(
 
             let (body_chan, body_port) = ipc::channel().unwrap();
 
-            {
-                let requester = chunk_requester.lock();
+            if let Ok(requester) = chunk_requester.lock() {
                 let _ = requester.send(BodyChunkRequest::Connect(body_chan));
 
                 // https://fetch.spec.whatwg.org/#concept-request-transmit-body
@@ -705,7 +713,7 @@ async fn obtain_response(
                         },
                     };
 
-                    devtools_bytes.lock().extend_from_slice(&bytes);
+                    devtools_bytes.lock().unwrap().extend_from_slice(&bytes);
 
                     // Step 5.1.2.2, transmit chunk over the network,
                     // currently implemented by sending the bytes to the fetch worker.
@@ -713,7 +721,10 @@ async fn obtain_response(
 
                     // Step 5.1.2.3
                     // Request the next chunk.
-                    let _ = chunk_requester2.lock().send(BodyChunkRequest::Chunk);
+                    let _ = chunk_requester2
+                        .lock()
+                        .unwrap()
+                        .send(BodyChunkRequest::Chunk);
                 }),
             );
 
@@ -755,6 +766,7 @@ async fn obtain_response(
         context
             .timing
             .lock()
+            .unwrap()
             .set_attribute(ResourceAttribute::DomainLookupStart);
 
         // TODO(#21261) connect_start: set if a persistent connection is *not* used and the last non-redirected
@@ -763,6 +775,7 @@ async fn obtain_response(
         context
             .timing
             .lock()
+            .unwrap()
             .set_attribute(ResourceAttribute::ConnectStart(connect_start));
 
         // TODO: We currently don't know when the handhhake before the connection is done
@@ -772,6 +785,7 @@ async fn obtain_response(
             context
                 .timing
                 .lock()
+                .unwrap()
                 .set_attribute(ResourceAttribute::SecureConnectionStart);
         }
 
@@ -785,6 +799,7 @@ async fn obtain_response(
         context
             .timing
             .lock()
+            .unwrap()
             .set_attribute(ResourceAttribute::ConnectEnd(connect_end));
 
         let request_id = request_id.map(|v| v.to_owned());
@@ -813,7 +828,7 @@ async fn obtain_response(
                                 closure_url,
                                 method.clone(),
                                 headers,
-                                Some(devtools_bytes.lock().clone()),
+                                Some(devtools_bytes.lock().unwrap().clone()),
                                 pipeline_id,
                                 (connect_end - connect_start).unsigned_abs(),
                                 (send_end - send_start).unsigned_abs(),
@@ -890,11 +905,11 @@ pub async fn http_fetch(
             // nothing to do, since actual_response is a function on response
 
             // Subsubstep 3
-            if (res.response_type == ResponseType::Opaque && request.mode != RequestMode::NoCors) ||
-                (res.response_type == ResponseType::OpaqueRedirect &&
-                    request.redirect_mode != RedirectMode::Manual) ||
-                (res.url_list.len() > 1 && request.redirect_mode != RedirectMode::Follow) ||
-                res.is_network_error()
+            if (res.response_type == ResponseType::Opaque && request.mode != RequestMode::NoCors)
+                || (res.response_type == ResponseType::OpaqueRedirect
+                    && request.redirect_mode != RedirectMode::Manual)
+                || (res.url_list.len() > 1 && request.redirect_mode != RedirectMode::Follow)
+                || res.is_network_error()
             {
                 return Response::network_error(NetworkError::Internal("Request failed".into()));
             }
@@ -910,11 +925,11 @@ pub async fn http_fetch(
         if cors_preflight_flag {
             let method_cache_match = cache.match_method(request, request.method.clone());
 
-            let method_mismatch = !method_cache_match &&
-                (!is_cors_safelisted_method(&request.method) || request.use_cors_preflight);
+            let method_mismatch = !method_cache_match
+                && (!is_cors_safelisted_method(&request.method) || request.use_cors_preflight);
             let header_mismatch = request.headers.iter().any(|(name, value)| {
-                !cache.match_header(request, name) &&
-                    !is_cors_safelisted_request_header(&name, &value)
+                !cache.match_header(request, name)
+                    && !is_cors_safelisted_request_header(&name, &value)
             });
 
             // Sub-substep 1
@@ -938,6 +953,7 @@ pub async fn http_fetch(
         context
             .timing
             .lock()
+            .unwrap()
             .set_attribute(ResourceAttribute::RequestStart);
 
         let mut fetch_result = http_network_or_cache_fetch(
@@ -1028,6 +1044,7 @@ pub async fn http_fetch(
     context
         .timing
         .lock()
+        .unwrap()
         .set_attribute(ResourceAttribute::RedirectCount(
             fetch_params.request.redirect_count as u16,
         ));
@@ -1053,6 +1070,7 @@ impl Drop for RedirectEndTimer {
 
         resource_fetch_timing_opt.as_ref().map_or((), |t| {
             t.lock()
+                .unwrap()
                 .set_attribute(ResourceAttribute::RedirectEnd(RedirectEndValue::Zero));
         })
     }
@@ -1100,6 +1118,7 @@ pub async fn http_redirect_fetch(
     context
         .timing
         .lock()
+        .unwrap()
         .set_attribute(ResourceAttribute::RedirectStart(
             RedirectStartValue::FetchStart,
         ));
@@ -1107,17 +1126,20 @@ pub async fn http_redirect_fetch(
     context
         .timing
         .lock()
+        .unwrap()
         .set_attribute(ResourceAttribute::FetchStart);
 
     // start_time should equal redirect_start if nonzero; else fetch_start
     context
         .timing
         .lock()
+        .unwrap()
         .set_attribute(ResourceAttribute::StartTime(ResourceTimeValue::FetchStart));
 
     context
         .timing
         .lock()
+        .unwrap()
         .set_attribute(ResourceAttribute::StartTime(
             ResourceTimeValue::RedirectStart,
         )); // updates start_time only if redirect_start is nonzero (implying TAO)
@@ -1159,8 +1181,8 @@ pub async fn http_redirect_fetch(
 
     // Step 11: If internalResponse’s status is not 303, request’s body is non-null, and request’s
     // body’s source is null, then return a network error.
-    if response.actual_response().status != StatusCode::SEE_OTHER &&
-        request.body.as_ref().is_some_and(|b| b.source_is_null())
+    if response.actual_response().status != StatusCode::SEE_OTHER
+        && request.body.as_ref().is_some_and(|b| b.source_is_null())
     {
         return Response::network_error(NetworkError::Internal("Request body is not done".into()));
     }
@@ -1171,11 +1193,11 @@ pub async fn http_redirect_fetch(
         .status
         .try_code()
         .is_some_and(|code| {
-            ((code == StatusCode::MOVED_PERMANENTLY || code == StatusCode::FOUND) &&
-                request.method == Method::POST) ||
-                (code == StatusCode::SEE_OTHER &&
-                    request.method != Method::HEAD &&
-                    request.method != Method::GET)
+            ((code == StatusCode::MOVED_PERMANENTLY || code == StatusCode::FOUND)
+                && request.method == Method::POST)
+                || (code == StatusCode::SEE_OTHER
+                    && request.method != Method::HEAD
+                    && request.method != Method::GET)
         })
     {
         // Step 12.1
@@ -1234,6 +1256,7 @@ pub async fn http_redirect_fetch(
     context
         .timing
         .lock()
+        .unwrap()
         .set_attribute(ResourceAttribute::RedirectEnd(
             RedirectEndValue::ResponseEnd,
         ));
@@ -1266,9 +1289,9 @@ async fn http_network_or_cache_fetch(
     // TODO(#33616): Step 8. Run these steps, but abort when fetchParams is canceled:
     // Step 8.1. If request’s traversable for user prompts is "no-traversable"
     // and request’s redirect mode is "error", then set httpFetchParams to fetchParams and httpRequest to request.
-    let http_request = if fetch_params.request.traversable_for_user_prompts ==
-        TraversableForUserPrompts::NoTraversable &&
-        fetch_params.request.redirect_mode == RedirectMode::Error
+    let http_request = if fetch_params.request.traversable_for_user_prompts
+        == TraversableForUserPrompts::NoTraversable
+        && fetch_params.request.redirect_mode == RedirectMode::Error
     {
         http_fetch_params = fetch_params;
         &mut http_fetch_params.request
@@ -1338,8 +1361,8 @@ async fn http_network_or_cache_fetch(
 
     // Step 8.11: If httpRequest’s referrer is a URL, then:
     match http_request.referrer {
-        Referrer::ReferrerUrl(ref http_request_referrer) |
-        Referrer::Client(ref http_request_referrer) => {
+        Referrer::ReferrerUrl(ref http_request_referrer)
+        | Referrer::Client(ref http_request_referrer) => {
             // Step 8.11.1: Let referrerValue be httpRequest’s referrer, serialized and isomorphic
             // encoded.
             if let Ok(referer) = http_request_referrer.as_str().parse::<Referer>() {
@@ -1462,9 +1485,9 @@ async fn http_network_or_cache_fetch(
             }
 
             // Substep 5
-            if authentication_fetch_flag &&
-                authorization_value.is_none() &&
-                has_credentials(&current_url)
+            if authentication_fetch_flag
+                && authorization_value.is_none()
+                && has_credentials(&current_url)
             {
                 authorization_value = Some(Authorization::basic(
                     current_url.username(),
@@ -1515,17 +1538,17 @@ async fn http_network_or_cache_fetch(
         // inclusive, invalidate appropriate stored responses in httpCache, as per the
         // "Invalidating Stored Responses" chapter of HTTP Caching, and set storedResponse to null.
         if forward_response.status.in_range(200..=399) && !http_request.method.is_safe() {
-            let mut http_cache = context.state.http_cache.write();
-            http_cache.invalidate(http_request, &forward_response);
+            if let Ok(mut http_cache) = context.state.http_cache.write() {
+                http_cache.invalidate(http_request, &forward_response);
+            }
         }
 
         // Step 10.4 If the revalidatingFlag is set and forwardResponse’s status is 304, then:
         if revalidating_flag && forward_response.status == StatusCode::NOT_MODIFIED {
-            // Ensure done_chan is None,
-            // since the network response will be replaced by the revalidated stored one.
-            *done_chan = None;
-            {
-                let mut http_cache = context.state.http_cache.write();
+            if let Ok(mut http_cache) = context.state.http_cache.write() {
+                // Ensure done_chan is None,
+                // since the network response will be replaced by the revalidated stored one.
+                *done_chan = None;
                 response = http_cache.refresh(http_request, forward_response.clone(), done_chan);
             }
             wait_for_cached_response(done_chan, &mut response).await;
@@ -1544,8 +1567,9 @@ async fn http_network_or_cache_fetch(
             if http_request.cache_mode != CacheMode::NoStore {
                 // Step 10.5.2 Store httpRequest and forwardResponse in httpCache, as per the
                 //             "Storing Responses in Caches" chapter of HTTP Caching.
-                let mut http_cache = context.state.http_cache.write();
-                http_cache.store(http_request, forward_response);
+                if let Ok(mut http_cache) = context.state.http_cache.write() {
+                    http_cache.store(http_request, forward_response);
+                }
             }
         }
     }
@@ -1558,9 +1582,9 @@ async fn http_network_or_cache_fetch(
 
     // FIXME: The spec doesn't tell us to do this *here*, but if we don't do it then
     // tests fail. Where should we do it instead? See also #33615
-    if http_request.response_tainting != ResponseTainting::CorsTainting &&
-        cross_origin_resource_policy_check(http_request, &response) ==
-            CrossOriginResourcePolicy::Blocked
+    if http_request.response_tainting != ResponseTainting::CorsTainting
+        && cross_origin_resource_policy_check(http_request, &response)
+            == CrossOriginResourcePolicy::Blocked
     {
         return Response::network_error(NetworkError::Internal(
             "Cross-origin resource policy check failed".into(),
@@ -1581,10 +1605,10 @@ async fn http_network_or_cache_fetch(
     // TODO(#33616): Figure out what to do with request window objects
     // NOTE: Requiring a WWW-Authenticate header here is ad-hoc, but seems to match what other browsers are
     // doing. See Step 14.1.
-    if response.status.try_code() == Some(StatusCode::UNAUTHORIZED) &&
-        !cors_flag &&
-        include_credentials &&
-        response.headers.contains_key(WWW_AUTHENTICATE)
+    if response.status.try_code() == Some(StatusCode::UNAUTHORIZED)
+        && !cors_flag
+        && include_credentials
+        && response.headers.contains_key(WWW_AUTHENTICATE)
     {
         // TODO: Step 14.1 Spec says requires testing on multiple WWW-Authenticate headers
 
@@ -1661,7 +1685,7 @@ async fn http_network_or_cache_fetch(
             password: credentials.password,
         };
         {
-            let mut auth_cache = context.state.auth_cache.write();
+            let mut auth_cache = context.state.auth_cache.write().unwrap();
             let key = request.current_url().origin().ascii_serialization();
             auth_cache.entries.insert(key, entry);
         }
@@ -1713,7 +1737,7 @@ fn block_for_cache_ready(
 ) {
     let (lock, cvar) = {
         let entry_key = CacheKey::new(http_request);
-        let mut state_map = context.state.http_cache_state.lock();
+        let mut state_map = context.state.http_cache_state.lock().unwrap();
         &*state_map
             .entry(entry_key)
             .or_insert_with(|| {
@@ -1726,9 +1750,12 @@ fn block_for_cache_ready(
     };
 
     // Start of critical section on http-cache state.
-    let mut state = lock.lock();
+    let mut state = lock.lock().unwrap();
     while let HttpCacheEntryState::PendingStore(_) = *state {
-        let time_out = cvar.wait_for(&mut state, Duration::from_millis(500));
+        let (current_state, time_out) = cvar
+            .wait_timeout(state, Duration::from_millis(500))
+            .unwrap();
+        state = current_state;
         if time_out.timed_out() {
             // After a timeout, ignore the pending store.
             break;
@@ -1737,68 +1764,68 @@ fn block_for_cache_ready(
 
     // TODO(#33616): Step 8.23 Set httpCache to the result of determining the
     // HTTP cache partition, given httpRequest.
-    let http_cache = context.state.http_cache.read();
-    // Step 8.25.1 Set storedResponse to the result of selecting a response from the httpCache,
-    //              possibly needing validation, as per the "Constructing Responses from Caches"
-    //              chapter of HTTP Caching, if any.
-    let stored_response = http_cache.construct_response(http_request, done_chan);
-
-    // Step 8.25.2 If storedResponse is non-null, then:
-    if let Some(response_from_cache) = stored_response {
-        let response_headers = response_from_cache.response.headers.clone();
-        // Substep 1, 2, 3, 4
-        let (cached_response, needs_revalidation) =
-            match (http_request.cache_mode, &http_request.mode) {
-                (CacheMode::ForceCache, _) => (Some(response_from_cache.response), false),
-                (CacheMode::OnlyIfCached, &RequestMode::SameOrigin) => {
-                    (Some(response_from_cache.response), false)
-                },
-                (CacheMode::OnlyIfCached, _) | (CacheMode::NoStore, _) | (CacheMode::Reload, _) => {
-                    (None, false)
-                },
-                (_, _) => (
-                    Some(response_from_cache.response),
-                    response_from_cache.needs_validation,
-                ),
-            };
+    if let Ok(http_cache) = context.state.http_cache.read() {
+        // Step 8.25.1 Set storedResponse to the result of selecting a response from the httpCache,
+        //              possibly needing validation, as per the "Constructing Responses from Caches"
+        //              chapter of HTTP Caching, if any.
+        let stored_response = http_cache.construct_response(http_request, done_chan);
+
+        // Step 8.25.2 If storedResponse is non-null, then:
+        if let Some(response_from_cache) = stored_response {
+            let response_headers = response_from_cache.response.headers.clone();
+            // Substep 1, 2, 3, 4
+            let (cached_response, needs_revalidation) =
+                match (http_request.cache_mode, &http_request.mode) {
+                    (CacheMode::ForceCache, _) => (Some(response_from_cache.response), false),
+                    (CacheMode::OnlyIfCached, &RequestMode::SameOrigin) => {
+                        (Some(response_from_cache.response), false)
+                    },
+                    (CacheMode::OnlyIfCached, _)
+                    | (CacheMode::NoStore, _)
+                    | (CacheMode::Reload, _) => (None, false),
+                    (_, _) => (
+                        Some(response_from_cache.response),
+                        response_from_cache.needs_validation,
+                    ),
+                };
 
-        if needs_revalidation {
-            *revalidating_flag = true;
-            // Substep 5
-            if let Some(http_date) = response_headers.typed_get::<LastModified>() {
-                let http_date: SystemTime = http_date.into();
-                http_request
-                    .headers
-                    .typed_insert(IfModifiedSince::from(http_date));
-            }
-            if let Some(entity_tag) = response_headers.get(header::ETAG) {
-                http_request
-                    .headers
-                    .insert(header::IF_NONE_MATCH, entity_tag.clone());
-            }
-        } else {
-            // Substep 6
-            *response = cached_response;
-            if let Some(response) = response {
-                response.cache_state = CacheState::Local;
-            }
-        }
-        if response.is_none() {
-            // Ensure the done chan is not set if we're not using the cached response,
-            // as the cache might have set it to Some if it constructed a pending response.
-            *done_chan = None;
-
-            // Update the cache state, incrementing the pending store count,
-            // or starting the count.
-            if let HttpCacheEntryState::PendingStore(i) = *state {
-                let new = i + 1;
-                *state = HttpCacheEntryState::PendingStore(new);
+            if needs_revalidation {
+                *revalidating_flag = true;
+                // Substep 5
+                if let Some(http_date) = response_headers.typed_get::<LastModified>() {
+                    let http_date: SystemTime = http_date.into();
+                    http_request
+                        .headers
+                        .typed_insert(IfModifiedSince::from(http_date));
+                }
+                if let Some(entity_tag) = response_headers.get(header::ETAG) {
+                    http_request
+                        .headers
+                        .insert(header::IF_NONE_MATCH, entity_tag.clone());
+                }
             } else {
-                *state = HttpCacheEntryState::PendingStore(1);
+                // Substep 6
+                *response = cached_response;
+                if let Some(response) = response {
+                    response.cache_state = CacheState::Local;
+                }
+            }
+            if response.is_none() {
+                // Ensure the done chan is not set if we're not using the cached response,
+                // as the cache might have set it to Some if it constructed a pending response.
+                *done_chan = None;
+
+                // Update the cache state, incrementing the pending store count,
+                // or starting the count.
+                if let HttpCacheEntryState::PendingStore(i) = *state {
+                    let new = i + 1;
+                    *state = HttpCacheEntryState::PendingStore(new);
+                } else {
+                    *state = HttpCacheEntryState::PendingStore(1);
+                }
             }
         }
     }
-
     // Notify the next thread waiting in line, if there is any.
     if *state == HttpCacheEntryState::ReadyToConstruct {
         cvar.notify_one();
@@ -1813,13 +1840,13 @@ fn block_for_cache_ready(
 fn update_http_cache_state(context: &FetchContext, http_request: &Request) {
     let (lock, cvar) = {
         let entry_key = CacheKey::new(http_request);
-        let mut state_map = context.state.http_cache_state.lock();
+        let mut state_map = context.state.http_cache_state.lock().unwrap();
         &*state_map
             .get_mut(&entry_key)
             .expect("Entry in http-cache state to have been previously inserted")
             .clone()
     };
-    let mut state = lock.lock();
+    let mut state = lock.lock().unwrap();
     if let HttpCacheEntryState::PendingStore(i) = *state {
         let new = i - 1;
         if new == 0 {
@@ -1906,9 +1933,9 @@ fn cross_origin_resource_policy_check(
     // Step 5
     if let Origin::Origin(ref request_origin) = request.origin {
         let schemeless_same_origin = is_schemelessy_same_site(request_origin, &current_url_origin);
-        if schemeless_same_origin &&
-            (request_origin.scheme() == Some("https") ||
-                response.https_state == HttpsState::None)
+        if schemeless_same_origin
+            && (request_origin.scheme() == Some("https")
+                || response.https_state == HttpsState::None)
         {
             return CrossOriginResourcePolicy::Allowed;
         }
@@ -1936,7 +1963,9 @@ impl Drop for ResponseEndTimer {
         let ResponseEndTimer(resource_fetch_timing_opt) = self;
 
         resource_fetch_timing_opt.as_ref().map_or((), |t| {
-            t.lock().set_attribute(ResourceAttribute::ResponseEnd);
+            t.lock()
+                .unwrap()
+                .set_attribute(ResourceAttribute::ResponseEnd);
         })
     }
 }
@@ -2000,7 +2029,7 @@ async fn http_network_fetch(
             // https://fetch.spec.whatwg.org/#websocket-opening-handshake
 
             let (resource_event_sender, dom_action_receiver) = {
-                let mut websocket_chan = context.websocket_chan.as_ref().unwrap().lock();
+                let mut websocket_chan = context.websocket_chan.as_ref().unwrap().lock().unwrap();
                 (
                     websocket_chan.sender.clone(),
                     websocket_chan.receiver.take().unwrap(),
@@ -2039,30 +2068,280 @@ async fn http_network_fetch(
             (Decoder::detect(response, url.is_secure_scheme()), None)
         },
         _ => {
-            let response_future = obtain_response(
-                &context.state.client,
-                &url,
-                &request.method,
-                &mut request.headers,
-                body,
-                request
-                    .body
-                    .as_ref()
-                    .is_some_and(|body| body.source_is_null()),
-                &request.pipeline_id,
-                Some(&request_id),
-                request.destination,
-                is_xhr,
-                context,
-                fetch_terminated_sender,
-                browsing_context_id,
+            // Check if this URL uses Unix socket or Tor transport
+            // Use transport info from request instead of re-parsing URL
+            use crate::transport_url::Transport;
+            use std::path::PathBuf;
+
+            let is_unix_socket = request.transport == Transport::Unix;
+            let is_tor = request.transport == Transport::Tor
+                || url
+                    .host_str()
+                    .map(|h| h.ends_with(".onion"))
+                    .unwrap_or(false);
+
+            debug!(
+                "Transport check: url={}, transport={:?}, socket_path={:?}, unix_client={}, is_tor={}",
+                url,
+                request.transport,
+                request.unix_socket_path,
+                context.state.unix_client.is_some(),
+                is_tor
             );
 
-            // This will only get the headers, the body is read later
-            let (res, msg) = match response_future.await {
-                Ok(wrapped_response) => wrapped_response,
-                Err(error) => return Response::network_error(error),
+            let (res, msg) = if is_tor {
+                // Tor network request path
+                let tor_manager = &context.state.tor_manager;
+
+                // Check if Tor is ready
+                let tor_status = tor_manager.status().await;
+                if !tor_status.is_ready() {
+                    // If requesting .onion, Tor must be enabled
+                    if url
+                        .host_str()
+                        .map(|h| h.ends_with(".onion"))
+                        .unwrap_or(false)
+                    {
+                        warn!("Tor not ready for .onion request: {:?}", tor_status);
+                        return Response::network_error(NetworkError::Internal(format!(
+                            "Tor network not ready (status: {}). Enable Tor to access .onion sites.",
+                            tor_status.display_name()
+                        )));
+                    }
+
+                    // For regular sites with explicit tor transport, also require Tor
+                    if request.transport == Transport::Tor {
+                        warn!(
+                            "Tor not ready for explicit Tor transport request: {:?}",
+                            tor_status
+                        );
+                        return Response::network_error(NetworkError::Internal(format!(
+                            "Tor network not ready (status: {}). Please wait for Tor to connect.",
+                            tor_status.display_name()
+                        )));
+                    }
+
+                    // Fall through to regular TCP for non-onion sites when Tor not ready
+                    // (This shouldn't happen with proper transport setting, but handle gracefully)
+                }
+
+                // Connect through Tor SOCKS5 proxy
+                let host = url.host_str().unwrap_or("localhost").to_string();
+                let port = url
+                    .port()
+                    .unwrap_or(if url.scheme() == "https" { 443 } else { 80 });
+
+                debug!("Connecting via Tor to {}:{}", host, port);
+
+                match tor_manager.connect(&host, port).await {
+                    Ok(_stream) => {
+                        info!("Tor connection established to {}:{}", host, port);
+
+                        // For now, return a placeholder indicating Tor connection works
+                        // Full HTTP request handling over Tor stream requires more integration
+                        // TODO: Implement full HTTP request/response over TcpStream via Tor
+                        return Response::network_error(NetworkError::Internal(format!(
+                            "Tor connection to {}:{} successful but HTTP over Tor not yet fully implemented",
+                            host, port
+                        )));
+                    },
+                    Err(e) => {
+                        warn!("Tor connection failed to {}:{}: {}", host, port, e);
+                        return Response::network_error(NetworkError::Internal(format!(
+                            "Failed to connect via Tor: {}",
+                            e
+                        )));
+                    },
+                }
+            } else if is_unix_socket && context.state.unix_client.is_some() {
+                // Unix socket request path
+                let unix_client = context.state.unix_client.as_ref().unwrap();
+
+                // Get socket path directly from request
+                let socket_path_str = match &request.unix_socket_path {
+                    Some(path) => path.clone(),
+                    None => {
+                        warn!(
+                            "Unix transport request missing socket path for URL: {}",
+                            url
+                        );
+                        return Response::network_error(NetworkError::Internal(
+                            "Unix socket path not found in request".into(),
+                        ));
+                    },
+                };
+
+                let socket_path = PathBuf::from(socket_path_str);
+                debug!("Using Unix socket: {}", socket_path.display());
+
+                // Construct hyperlocal URI
+                let unix_uri: http::Uri = hyperlocal::Uri::new(&socket_path, url.path()).into();
+
+                // Build the HTTP request body with proper streaming support
+                let request_body = if let Some(chunk_requester) = body {
+                    let source_is_null = request
+                        .body
+                        .as_ref()
+                        .is_some_and(|body| body.source_is_null());
+
+                    let (sink, stream) = if source_is_null {
+                        // Chunked transfer encoding for streaming bodies
+                        let (sender, receiver) = channel(1);
+                        (BodySink::Chunked(sender), BodyStream::Chunked(receiver))
+                    } else {
+                        // Buffered body for non-streaming requests
+                        let (sender, receiver) = unbounded_channel();
+                        (BodySink::Buffered(sender), BodyStream::Buffered(receiver))
+                    };
+
+                    let (body_chan, body_port) = ipc::channel().unwrap();
+
+                    if let Ok(requester) = chunk_requester.lock() {
+                        let _ = requester.send(BodyChunkRequest::Connect(body_chan));
+                        let _ = requester.send(BodyChunkRequest::Chunk);
+                    }
+
+                    let chunk_requester2 = chunk_requester.clone();
+                    let fetch_terminated_sender2 = fetch_terminated_sender.clone();
+
+                    ROUTER.add_typed_route(
+                        body_port,
+                        Box::new(move |message| {
+                            let bytes = match message.unwrap() {
+                                BodyChunkResponse::Chunk(bytes) => bytes,
+                                BodyChunkResponse::Done => {
+                                    let _ = fetch_terminated_sender2.send(false);
+                                    sink.close();
+                                    return;
+                                },
+                                BodyChunkResponse::Error => {
+                                    let _ = fetch_terminated_sender2.send(true);
+                                    sink.close();
+                                    return;
+                                },
+                            };
+
+                            sink.transmit_bytes(bytes);
+
+                            let _ = chunk_requester2
+                                .lock()
+                                .unwrap()
+                                .send(BodyChunkRequest::Chunk);
+                        }),
+                    );
+
+                    match stream {
+                        BodyStream::Chunked(receiver) => {
+                            let stream = ReceiverStream::new(receiver);
+                            BoxBody::new(http_body_util::StreamBody::new(stream))
+                        },
+                        BodyStream::Buffered(mut receiver) => {
+                            // Accumulate bytes for buffered bodies
+                            let mut body_bytes = vec![];
+                            loop {
+                                match receiver.recv().await {
+                                    Some(BodyChunk::Chunk(bytes)) => {
+                                        body_bytes.extend_from_slice(&bytes);
+                                    },
+                                    Some(BodyChunk::Done) => break,
+                                    None => {
+                                        warn!(
+                                            "Failed to read all chunks from Unix socket request body"
+                                        );
+                                        break;
+                                    },
+                                }
+                            }
+                            Full::new(body_bytes.into())
+                                .map_err(|_| unreachable!())
+                                .boxed()
+                        },
+                    }
+                } else {
+                    http_body_util::Empty::new()
+                        .map_err(|_| unreachable!())
+                        .boxed()
+                };
+
+                // Build the HTTP request with headers
+                let mut builder = HyperRequest::builder()
+                    .method(&request.method)
+                    .uri(unix_uri);
+
+                // Copy headers from the original request
+                // This is critical for HTTP protocol compliance (Host, Accept, etc.)
+                for (name, value) in request.headers.iter() {
+                    builder = builder.header(name, value);
+                }
+
+                // Ensure Host header is set (required by HTTP/1.1)
+                // For Unix sockets, use "localhost" as the virtual host
+                if !request.headers.contains_key(header::HOST) {
+                    builder = builder.header(header::HOST, "localhost");
+                }
+
+                let hyper_request = match builder.body(request_body) {
+                    Ok(req) => req,
+                    Err(e) => {
+                        warn!("Failed to build Unix socket request: {}", e);
+                        return Response::network_error(NetworkError::Internal(format!(
+                            "Failed to build request: {}",
+                            e
+                        )));
+                    },
+                };
+
+                // Make the request
+                match unix_client.request(hyper_request).await {
+                    Ok(response) => {
+                        debug!(
+                            "Unix socket request succeeded with status: {}",
+                            response.status()
+                        );
+
+                        // Convert response body to BoxedBody
+                        let (parts, body) = response.into_parts();
+                        let boxed_body = body.map_err(Into::into).boxed();
+                        let response = HyperResponse::from_parts(parts, boxed_body);
+
+                        (Decoder::detect(response, false), None)
+                    },
+                    Err(e) => {
+                        warn!("Unix socket request failed: {}", e);
+                        return Response::network_error(NetworkError::Internal(format!(
+                            "Unix socket request failed: {}",
+                            e
+                        )));
+                    },
+                }
+            } else {
+                // Standard TCP request path
+                let response_future = obtain_response(
+                    &context.state.client,
+                    &url,
+                    &request.method,
+                    &mut request.headers,
+                    body,
+                    request
+                        .body
+                        .as_ref()
+                        .is_some_and(|body| body.source_is_null()),
+                    &request.pipeline_id,
+                    Some(&request_id),
+                    request.destination,
+                    is_xhr,
+                    context,
+                    fetch_terminated_sender,
+                    browsing_context_id,
+                );
+
+                // This will only get the headers, the body is read later
+                match response_future.await {
+                    Ok(wrapped_response) => wrapped_response,
+                    Err(error) => return Response::network_error(error),
+                }
             };
+
             (res, msg)
         },
     };
@@ -2111,10 +2390,10 @@ async fn http_network_fetch(
     });
 
     if !(is_same_origin || req_origin_in_timing_allow || wildcard_present) {
-        context.timing.lock().mark_timing_check_failed();
+        context.timing.lock().unwrap().mark_timing_check_failed();
     }
 
-    let timing = context.timing.lock().clone();
+    let timing = context.timing.lock().unwrap().clone();
     let mut response = Response::new(url.clone(), timing);
 
     let status_text = res
@@ -2143,11 +2422,11 @@ async fn http_network_fetch(
         return Response::network_error(NetworkError::Internal("Fetch aborted".into()));
     }
 
-    *res_body.lock() = ResponseBody::Receiving(vec![]);
+    *res_body.lock().unwrap() = ResponseBody::Receiving(vec![]);
     let res_body2 = res_body.clone();
 
     if let Some(ref sender) = devtools_sender {
-        let sender = sender.lock();
+        let sender = sender.lock().unwrap();
         if let Some(m) = msg {
             send_request_to_devtools(m, &sender);
         }
@@ -2172,11 +2451,11 @@ async fn http_network_fetch(
             })
             .try_fold(res_body, move |res_body, chunk| {
                 if cancellation_listener.cancelled() {
-                    *res_body.lock() = ResponseBody::Done(vec![]);
+                    *res_body.lock().unwrap() = ResponseBody::Done(vec![]);
                     let _ = done_sender.send(Data::Cancelled);
                     return future::ready(Err(()));
                 }
-                if let ResponseBody::Receiving(ref mut body) = *res_body.lock() {
+                if let ResponseBody::Receiving(ref mut body) = *res_body.lock().unwrap() {
                     let bytes = chunk;
                     body.extend_from_slice(&bytes);
                     let _ = done_sender.send(Data::Payload(bytes.to_vec()));
@@ -2185,7 +2464,7 @@ async fn http_network_fetch(
             })
             .and_then(move |res_body| {
                 debug!("successfully finished response for {:?}", url1);
-                let mut body = res_body.lock();
+                let mut body = res_body.lock().unwrap();
                 let completed_body = match *body {
                     ResponseBody::Receiving(ref mut body) => std::mem::take(body),
                     _ => vec![],
@@ -2202,13 +2481,14 @@ async fn http_network_fetch(
                 );
                 timing_ptr2
                     .lock()
+                    .unwrap()
                     .set_attribute(ResourceAttribute::ResponseEnd);
                 let _ = done_sender2.send(Data::Done);
                 future::ready(Ok(()))
             })
             .map_err(move |_| {
                 debug!("finished response for {:?}", url2);
-                let mut body = res_body2.lock();
+                let mut body = res_body2.lock().unwrap();
                 let completed_body = match *body {
                     ResponseBody::Receiving(ref mut body) => std::mem::take(body),
                     _ => vec![],
@@ -2216,6 +2496,7 @@ async fn http_network_fetch(
                 *body = ResponseBody::Done(completed_body);
                 timing_ptr3
                     .lock()
+                    .unwrap()
                     .set_attribute(ResourceAttribute::ResponseEnd);
                 let _ = done_sender3.send(Data::Done);
             }),
@@ -2250,6 +2531,7 @@ async fn http_network_fetch(
         .state
         .hsts_list
         .write()
+        .unwrap()
         .update_hsts_list_from_response(&url, &response.headers);
 
     // TODO these steps
@@ -2393,10 +2675,10 @@ async fn cors_preflight_fetch(
         // and request’s credentials mode is "include" or methods does not contain `*`, then return a network error.
         if methods
             .iter()
-            .all(|method| *method.as_str() != *request.method.as_ref()) &&
-            !is_cors_safelisted_method(&request.method) &&
-            (request.credentials_mode == CredentialsMode::Include ||
-                methods.iter().all(|method| method.as_ref() != "*"))
+            .all(|method| *method.as_str() != *request.method.as_ref())
+            && !is_cors_safelisted_method(&request.method)
+            && (request.credentials_mode == CredentialsMode::Include
+                || methods.iter().all(|method| method.as_ref() != "*"))
         {
             return Response::network_error(NetworkError::Internal(
                 "CORS method check failed".into(),
@@ -2411,8 +2693,8 @@ async fn cors_preflight_fetch(
         // Step 7.6 If one of request’s header list’s names is a CORS non-wildcard request-header name
         // and is not a byte-case-insensitive match for an item in headerNames, then return a network error.
         if request.headers.iter().any(|(name, _)| {
-            is_cors_non_wildcard_request_header_name(name) &&
-                header_names.iter().all(|header_name| header_name != name)
+            is_cors_non_wildcard_request_header_name(name)
+                && header_names.iter().all(|header_name| header_name != name)
         }) {
             return Response::network_error(NetworkError::Internal(
                 "CORS authorization check failed".into(),
@@ -2428,9 +2710,9 @@ async fn cors_preflight_fetch(
             .iter()
             .any(|header_name| header_name.as_str() == "*");
         for unsafe_name in unsafe_names.iter() {
-            if !header_names_set.contains(unsafe_name) &&
-                (request.credentials_mode == CredentialsMode::Include ||
-                    !header_names_contains_star)
+            if !header_names_set.contains(unsafe_name)
+                && (request.credentials_mode == CredentialsMode::Include
+                    || !header_names_contains_star)
             {
                 return Response::network_error(NetworkError::Internal(
                     "CORS headers check failed".into(),
@@ -2487,8 +2769,8 @@ fn cors_check(request: &Request, response: &Response) -> Result<(), ()> {
     let origin = origin.ok_or(())?;
 
     // Step 3
-    if request.credentials_mode != CredentialsMode::Include &&
-        origin == AccessControlAllowOrigin::ANY
+    if request.credentials_mode != CredentialsMode::Include
+        && origin == AccessControlAllowOrigin::ANY
     {
         return Ok(());
     }
@@ -2529,22 +2811,22 @@ fn has_credentials(url: &ServoUrl) -> bool {
 }
 
 fn is_no_store_cache(headers: &HeaderMap) -> bool {
-    headers.contains_key(header::IF_MODIFIED_SINCE) |
-        headers.contains_key(header::IF_NONE_MATCH) |
-        headers.contains_key(header::IF_UNMODIFIED_SINCE) |
-        headers.contains_key(header::IF_MATCH) |
-        headers.contains_key(header::IF_RANGE)
+    headers.contains_key(header::IF_MODIFIED_SINCE)
+        | headers.contains_key(header::IF_NONE_MATCH)
+        | headers.contains_key(header::IF_UNMODIFIED_SINCE)
+        | headers.contains_key(header::IF_MATCH)
+        | headers.contains_key(header::IF_RANGE)
 }
 
 /// <https://fetch.spec.whatwg.org/#redirect-status>
 fn is_redirect_status(status: StatusCode) -> bool {
     matches!(
         status,
-        StatusCode::MOVED_PERMANENTLY |
-            StatusCode::FOUND |
-            StatusCode::SEE_OTHER |
-            StatusCode::TEMPORARY_REDIRECT |
-            StatusCode::PERMANENT_REDIRECT
+        StatusCode::MOVED_PERMANENTLY
+            | StatusCode::FOUND
+            | StatusCode::SEE_OTHER
+            | StatusCode::TEMPORARY_REDIRECT
+            | StatusCode::PERMANENT_REDIRECT
     )
 }
 
@@ -2627,8 +2909,8 @@ fn append_a_request_origin_header(request: &mut Request) {
 
     // Step 3. If request’s response tainting is "cors" or request’s mode is "websocket",
     //         then append (`Origin`, serializedOrigin) to request’s header list.
-    if request.response_tainting == ResponseTainting::CorsTainting ||
-        matches!(request.mode, RequestMode::WebSocket { .. })
+    if request.response_tainting == ResponseTainting::CorsTainting
+        || matches!(request.mode, RequestMode::WebSocket { .. })
     {
         request.headers.typed_insert(serialized_origin);
     }
@@ -2641,9 +2923,9 @@ fn append_a_request_origin_header(request: &mut Request) {
                     // Set serializedOrigin to `null`.
                     serialized_origin = headers::Origin::NULL;
                 },
-                ReferrerPolicy::NoReferrerWhenDowngrade |
-                ReferrerPolicy::StrictOrigin |
-                ReferrerPolicy::StrictOriginWhenCrossOrigin => {
+                ReferrerPolicy::NoReferrerWhenDowngrade
+                | ReferrerPolicy::StrictOrigin
+                | ReferrerPolicy::StrictOriginWhenCrossOrigin => {
                     // If request’s origin is a tuple origin, its scheme is "https", and
                     // request’s current URL’s scheme is not "https", then set serializedOrigin to `null`.
                     if let ImmutableOrigin::Tuple(scheme, _, _) = &request_origin {
