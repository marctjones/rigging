diff --git a/components/net/unix_connector.rs b/components/net/unix_connector.rs
new file mode 100644
index 00000000000..eba505ccc2b
--- /dev/null
+++ b/components/net/unix_connector.rs
@@ -0,0 +1,223 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
+
+//! Unix domain socket connector for Servo networking
+
+use std::collections::HashMap;
+use std::path::{Path, PathBuf};
+use std::sync::{Arc, RwLock};
+use std::task::{Context, Poll};
+
+use http::uri::Uri;
+use hyperlocal::UnixConnector as HyperlocalConnector;
+use log::{debug, warn};
+use tower_service::Service;
+
+/// Validates a socket path for security concerns
+///
+/// This function checks for:
+/// - Directory traversal attempts (../)
+/// - Null bytes in path
+/// - Absolute paths that escape allowed directories
+///
+/// Returns true if the path is safe to use, false otherwise.
+fn validate_socket_path(socket_path: &Path, allowed_base: Option<&Path>) -> bool {
+    // Convert to string for validation
+    let path_str = match socket_path.to_str() {
+        Some(s) => s,
+        None => {
+            warn!("Socket path contains invalid UTF-8");
+            return false;
+        },
+    };
+
+    // Check for null bytes (security issue)
+    if path_str.contains('\0') {
+        warn!("Socket path contains null bytes: {:?}", socket_path);
+        return false;
+    }
+
+    // Check for directory traversal attempts
+    if path_str.contains("../") || path_str.contains("..\\") {
+        warn!(
+            "Socket path contains directory traversal: {:?}",
+            socket_path
+        );
+        return false;
+    }
+
+    // Normalize the path and check if it's within allowed base
+    if let Some(base) = allowed_base {
+        // Canonicalize paths if they exist, otherwise just check components
+        let canonical_path = socket_path
+            .canonicalize()
+            .unwrap_or_else(|_| socket_path.to_path_buf());
+        let canonical_base = base.canonicalize().unwrap_or_else(|_| base.to_path_buf());
+
+        if !canonical_path.starts_with(&canonical_base) {
+            warn!(
+                "Socket path {:?} is outside allowed directory {:?}",
+                socket_path, base
+            );
+            return false;
+        }
+    }
+
+    // Additional check: ensure path components don't contain suspicious characters
+    for component in socket_path.components() {
+        if let Some(component_str) = component.as_os_str().to_str() {
+            // Check for hidden or suspicious patterns
+            if component_str.starts_with('.') && component_str != "." && component_str != ".." {
+                debug!("Socket path contains hidden component: {}", component_str);
+                // Allow hidden files but log it
+            }
+        }
+    }
+
+    true
+}
+
+/// Mapping configuration for URL hostnames to Unix socket paths
+#[derive(Clone, Debug)]
+pub struct SocketMapping {
+    mappings: Arc<RwLock<HashMap<String, PathBuf>>>,
+    default_socket_dir: PathBuf,
+}
+
+impl SocketMapping {
+    /// Create a new socket mapping with a default directory
+    pub fn new(default_dir: PathBuf) -> Self {
+        Self {
+            mappings: Arc::new(RwLock::new(HashMap::new())),
+            default_socket_dir: default_dir,
+        }
+    }
+
+    /// Add a custom mapping from hostname to socket path
+    pub fn add_mapping(&self, host: String, socket_path: PathBuf) {
+        // Validate socket path for security
+        if !validate_socket_path(&socket_path, Some(&self.default_socket_dir)) {
+            warn!(
+                "Rejecting invalid socket path for host '{}': {}",
+                host,
+                socket_path.display()
+            );
+            return;
+        }
+
+        debug!("Adding UDS mapping: {} -> {}", host, socket_path.display());
+        match self.mappings.write() {
+            Ok(mut mappings) => {
+                mappings.insert(host, socket_path);
+            },
+            Err(e) => {
+                log::error!("Failed to acquire write lock for socket mappings: {}", e);
+            },
+        }
+    }
+
+    /// Get the socket path for a given hostname
+    pub fn get_socket_path(&self, host: &str) -> PathBuf {
+        match self.mappings.read() {
+            Ok(mappings) => mappings.get(host).cloned().unwrap_or_else(|| {
+                // Default mapping: hostname to socket file in default directory
+                let socket_path = self.default_socket_dir.join(format!("{}.sock", host));
+                debug!(
+                    "No explicit mapping for '{}', using default: {}",
+                    host,
+                    socket_path.display()
+                );
+                socket_path
+            }),
+            Err(e) => {
+                log::error!("Failed to acquire read lock for socket mappings: {}", e);
+                // Fallback to default path on lock failure
+                let socket_path = self.default_socket_dir.join(format!("{}.sock", host));
+                log::warn!("Using fallback socket path: {}", socket_path.display());
+                socket_path
+            },
+        }
+    }
+
+    /// Get socket path from a URL using the extended URL spec (path-based)
+    pub fn get_socket_path_from_url(&self, url_str: &str) -> Option<PathBuf> {
+        use crate::transport_url::TransportUrl;
+
+        // Parse URL using TransportUrl to detect Unix socket transport
+        // Per the extended URL spec, the authority component IS the socket path
+        if let Ok(transport_url) = TransportUrl::parse(url_str) {
+            if let Some(socket_path_str) = transport_url.unix_socket_path() {
+                let socket_path = PathBuf::from(socket_path_str);
+
+                // Validate the socket path for security
+                if !validate_socket_path(&socket_path, None) {
+                    warn!(
+                        "Rejecting invalid socket path from URL: {}",
+                        socket_path.display()
+                    );
+                    return None;
+                }
+
+                debug!("Using socket path from URL: {}", socket_path.display());
+                return Some(socket_path);
+            }
+        }
+
+        debug!("Could not determine socket path from URL: {}", url_str);
+        None
+    }
+}
+
+/// A connector that uses Unix domain sockets instead of TCP
+#[derive(Clone)]
+pub struct ServoUnixConnector {
+    inner: HyperlocalConnector,
+    mapping: SocketMapping,
+}
+
+impl ServoUnixConnector {
+    /// Create a new Unix socket connector with the given mapping
+    pub fn new(mapping: SocketMapping) -> Self {
+        Self {
+            inner: HyperlocalConnector,
+            mapping,
+        }
+    }
+}
+
+impl Service<Uri> for ServoUnixConnector {
+    type Response = <HyperlocalConnector as Service<Uri>>::Response;
+    type Error = <HyperlocalConnector as Service<Uri>>::Error;
+    type Future = <HyperlocalConnector as Service<Uri>>::Future;
+
+    fn call(&mut self, uri: Uri) -> Self::Future {
+        // Convert HTTP URL to Unix socket URI
+        let socket_uri = if let Some(auth) = uri.authority() {
+            let host = auth.host();
+            let socket_path = self.mapping.get_socket_path(host);
+
+            // Get the path and query from the original URI
+            let path_and_query = uri.path_and_query().map(|pq| pq.as_str()).unwrap_or("/");
+
+            debug!(
+                "Converting {} to Unix socket: {} (path: {})",
+                uri,
+                socket_path.display(),
+                path_and_query
+            );
+
+            // hyperlocal expects URIs like: unix://[socket_path][http_path]
+            hyperlocal::Uri::new(&socket_path, path_and_query).into()
+        } else {
+            // If no authority, pass through as-is
+            uri
+        };
+
+        self.inner.call(socket_uri)
+    }
+
+    fn poll_ready(&mut self, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {
+        self.inner.poll_ready(cx)
+    }
+}
