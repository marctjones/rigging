diff --git a/components/net/connector.rs b/components/net/connector.rs
index 3adb53d8f69..032a150653e 100644
--- a/components/net/connector.rs
+++ b/components/net/connector.rs
@@ -8,6 +8,7 @@ use std::sync::Arc;
 use std::time::Duration;
 use std::{fmt, io};
 
+use aws_lc_rs;
 use futures::task::{Context, Poll};
 use futures::{Future, TryFutureExt};
 use http::uri::{Authority, Uri as Destination};
@@ -25,7 +26,7 @@ use log::warn;
 use parking_lot::Mutex;
 use rustls::client::danger::ServerCertVerifier;
 use rustls::client::{ClientConnection, EchStatus};
-use rustls::crypto::{CryptoProvider, aws_lc_rs};
+use rustls::crypto::CryptoProvider;
 use rustls::{ClientConfig, ProtocolVersion};
 use rustls_pki_types::{CertificateDer, ServerName, UnixTime};
 use servo_config::pref;
@@ -429,7 +430,7 @@ impl CertificateVerificationOverrideVerifier {
         let use_webpki_roots = cfg!(target_os = "android") || pref!(network_use_webpki_roots);
         let main_verifier = if !use_webpki_roots {
             let crypto_provider = CryptoProvider::get_default()
-                .unwrap_or(&Arc::new(aws_lc_rs::default_provider()))
+                .expect("No default crypto provider installed")
                 .clone();
             let verifier = match ca_certficates {
                 CACertificates::Default => rustls_platform_verifier::Verifier::new(crypto_provider),
@@ -622,3 +623,39 @@ pub fn create_http_client(tls_config: TlsConfig) -> ServoClient {
         .http1_title_case_headers(true)
         .build(InstrumentedConnector::from(connector))
 }
+
+/// Create HTTP client with optional custom connector
+///
+/// This function allows applications (via Rigging) to inject a custom connector
+/// for transport-aware URLs (Unix sockets, Tor, etc.). If no custom connector
+/// is provided, falls back to the default HTTPS connector.
+///
+/// # Arguments
+/// * `tls_config` - TLS configuration for HTTPS
+/// * `custom_connector` - Optional custom connector (e.g., Rigging's ComposedConnector)
+///
+/// # Returns
+/// Configured HTTP client with the specified connector
+pub fn create_http_client_with_connector<C>(
+    tls_config: TlsConfig,
+    custom_connector: Option<C>,
+) -> Client<C, BoxedBody>
+where
+    C: Service<http::Uri> + Clone + Send + Sync + 'static,
+    C::Response: hyper::rt::Read + hyper::rt::Write + Connection + Unpin + Send + 'static,
+    C::Future: Send + Unpin + 'static,
+    C::Error: Into<BoxError>,
+{
+    let connector = custom_connector.unwrap_or_else(|| {
+        hyper_rustls::HttpsConnectorBuilder::new()
+            .with_tls_config(tls_config)
+            .https_or_http()
+            .enable_http1()
+            .enable_http2()
+            .wrap_connector(ProxyConnector::new())
+    });
+
+    Client::builder(TokioExecutor {})
+        .http1_title_case_headers(true)
+        .build(connector)
+}
diff --git a/components/servo/servo.rs b/components/servo/servo.rs
index db80efba74c..d49caad6921 100644
--- a/components/servo/servo.rs
+++ b/components/servo/servo.rs
@@ -1227,6 +1227,8 @@ pub struct ServoBuilder {
     protocol_registry: ProtocolRegistry,
     #[cfg(feature = "webxr")]
     webxr_registry: Box<dyn webxr::WebXrRegistry>,
+    /// Optional custom HTTP connector for transport-aware URLs
+    custom_connector: Option<Box<dyn std::any::Any + Send>>,
 }
 
 impl Default for ServoBuilder {
@@ -1238,6 +1240,7 @@ impl Default for ServoBuilder {
             protocol_registry: Default::default(),
             #[cfg(feature = "webxr")]
             webxr_registry: Box::new(DefaultWebXrRegistry),
+            custom_connector: None,
         }
     }
 }
@@ -1272,6 +1275,29 @@ impl ServoBuilder {
         self.webxr_registry = webxr_registry;
         self
     }
+
+    /// Set a custom HTTP connector for transport-aware URLs
+    ///
+    /// This allows applications (via Rigging) to inject custom connectors
+    /// for Unix sockets, Tor, named pipes, etc.
+    ///
+    /// # Arguments
+    /// * `connector` - Custom connector implementing tower::Service<Uri>
+    ///
+    /// # Example
+    /// ```ignore
+    /// let connector = ComposedConnector::new(config);
+    /// let servo = ServoBuilder::default()
+    ///     .with_connector(connector)
+    ///     .build();
+    /// ```
+    pub fn with_connector<C>(mut self, connector: C) -> Self
+    where
+        C: Send + 'static,
+    {
+        self.custom_connector = Some(Box::new(connector));
+        self
+    }
 }
 
 fn register_system_memory_reporter_for_event_loop(
