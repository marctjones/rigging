diff --git a/components/net/connector.rs b/components/net/connector.rs
index 3adb53d8f69..cb18b2e950c 100644
--- a/components/net/connector.rs
+++ b/components/net/connector.rs
@@ -622,3 +622,39 @@ pub fn create_http_client(tls_config: TlsConfig) -> ServoClient {
         .http1_title_case_headers(true)
         .build(InstrumentedConnector::from(connector))
 }
+
+/// Create HTTP client with optional custom connector
+///
+/// This function allows applications (via Rigging) to inject a custom connector
+/// for transport-aware URLs (Unix sockets, Tor, etc.). If no custom connector
+/// is provided, falls back to the default HTTPS connector.
+///
+/// # Arguments
+/// * `tls_config` - TLS configuration for HTTPS
+/// * `custom_connector` - Optional custom connector (e.g., Rigging's ComposedConnector)
+///
+/// # Returns
+/// Configured HTTP client with the specified connector
+pub fn create_http_client_with_connector<C>(
+    tls_config: TlsConfig,
+    custom_connector: Option<C>,
+) -> Client<C, BoxedBody>
+where
+    C: Service<http::Uri> + Clone + Send + Sync + 'static,
+    C::Response: hyper::rt::Read + hyper::rt::Write + Connection + Unpin + Send + 'static,
+    C::Future: Send + 'static,
+    C::Error: Into<BoxError>,
+{
+    let connector = custom_connector.unwrap_or_else(|| {
+        hyper_rustls::HttpsConnectorBuilder::new()
+            .with_tls_config(tls_config)
+            .https_or_http()
+            .enable_http1()
+            .enable_http2()
+            .wrap_connector(ProxyConnector::new())
+    });
+
+    Client::builder(TokioExecutor {})
+        .http1_title_case_headers(true)
+        .build(connector)
+}
diff --git a/components/servo/servo.rs b/components/servo/servo.rs
index 5d28b3d7e55..2d3e48cf7d3 100644
--- a/components/servo/servo.rs
+++ b/components/servo/servo.rs
@@ -1227,6 +1227,8 @@ pub struct ServoBuilder {
     protocol_registry: ProtocolRegistry,
     #[cfg(feature = "webxr")]
     webxr_registry: Box<dyn webxr::WebXrRegistry>,
+    /// Optional custom HTTP connector for transport-aware URLs
+    custom_connector: Option<Box<dyn std::any::Any + Send>>,
 }

 impl Default for ServoBuilder {
@@ -1237,6 +1239,7 @@ impl Default for ServoBuilder {
             protocol_registry: Default::default(),
             #[cfg(feature = "webxr")]
             webxr_registry: Box::new(DefaultWebXrRegistry),
+            custom_connector: None,
         }
     }
 }
@@ -1273,6 +1276,29 @@ impl ServoBuilder {
         self.webxr_registry = webxr_registry;
         self
     }
+
+    /// Set a custom HTTP connector for transport-aware URLs
+    ///
+    /// This allows applications (via Rigging) to inject custom connectors
+    /// for Unix sockets, Tor, named pipes, etc.
+    ///
+    /// # Arguments
+    /// * `connector` - Custom connector implementing tower::Service<Uri>
+    ///
+    /// # Example
+    /// ```ignore
+    /// let connector = ComposedConnector::new(config);
+    /// let servo = ServoBuilder::default()
+    ///     .with_connector(connector)
+    ///     .build();
+    /// ```
+    pub fn with_connector<C>(mut self, connector: C) -> Self
+    where
+        C: Send + 'static,
+    {
+        self.custom_connector = Some(Box::new(connector));
+        self
+    }
 }

 fn register_system_memory_reporter_for_event_loop(
